# Как был написан эзотерический полиглот

**Шаги**:

1. *Идея*
2. *Malbolge*
3. *Brainfuck*
4. *Spoon*
5. *123*
6. *asdf*
7. *EXCON*
8. *Whitespace*
9. *Окончание*

## Идея
Полиглот в программировании - это корректная программа, написанная одновременно на нескольких языках программирования. Как правило, вывод такой программы не зависит от того, интерпретатор какого конкретно языка ее исполняет. В крайнем случае вывод строится по некоему шаблону.

Наш полиглот будет выводить в консоль **%название_языка% program**. Он отличается от большинства представителей семейства полиглотов - в его исходнике нет ни одного нормального языка. Только эзотерика, только хардкор! :)

Есть легкий способ сделать код корректным сразу на нескольких языках: их лексемы должны не пересекаться или совпадать по минимуму. Например, исходник на **123** состоит только из **1**,**2** и **3**, а исходник на **asdf** состоит из (внезапно) **a**,**s**,**d** и **f**.

Главная проблема при таком подходе - Malbolge. Его исходник может содержать любые [печатные символы](https://en.wikipedia.org/wiki/ASCII#Printable_characters) от **!** до **~**. Так что любая инструкция на любом другом языке должна быть корректной инструкцией для Malbolge. Он задает такт музыке, с него и начнем.

## Malbolge
Зачем писать исходник самому, когда можно переложить эту работу на компьютер? :) Что я и сделал, написав генератор исходников для Malbolge на языке системы Mathematica (сорян, ребят, я развлекался как мог).

Чтобы понять, как он работает, следует знать принцип работы интерпретатора Malbolge. Лучше всего для этого прочитать [оригинальную спецификацию](http://www.lscheffer.com/malbolge_spec.html) и [исходник оригинального интерпретатора](http://www.lscheffer.com/malbolge_interp.html). 
В языке есть всего 8 инструкций (**j**,**i**,__\*__,**p**,**<**,**/**,**v**,**o**), так что те исходники, которые вы видите в Интернете (в Википедии и пр.) - всего лишь их "зашифрованная" последовательность. Незашифрованная версия называется *нормализованный исходный код*, это название придумал [Эндрю Кук](http://www.acooke.org/malbolge.html), написавший первый *Hello world* (на самом деле он его тоже сгенерировал). Есть очень простое правило: код на Malbolge корректен, если его нормализованное представление состоит только из вышеуказанных 8 инструкций, да еще, быть может, пробельных символов, которые будут проигнорированы интерпретатором.

Виртуальная машина языка использует 3 регистра: **A** (аккумулятор), **C** (указатель на код) и **D** (указатель на данные).  Изначально все регистры установлены в *0*. То, что **C** и **D** указывают на одну и ту же инструкцию (а это значит, что исходный код одноврменно является и данными), крайне затрудняет формирование кода ASCII-символа для его вывода. Возможное решение заключается в разделении исходного кода на 2 части: собственно секция *кода* и секция *данных*. Единственный доступный метод разделения - jump в другое место исходного кода.

Чтобы понять, как это сделать, достаточно приглядеться к инструкциям языка. Например, заглянуть в [Википедию](https://en.wikipedia.org/wiki/Malbolge#Instructions). Как видно, есть 2 инструкции, которые позволяют выполнить jump: **i** (меняет значение **C**, указателя на код) и **j** (меняет значение **D**, указателя на данные).

В первом случае исходный код будет выглядеть примерно так:
```
...i[данные]...[код]
```
Во втором случае наоборот:
```
...j[код]...[данные]
```

Второй вариант нам не подходит, поскольку совершить jump можно максимум в инструкцию, располагающуюся на 40 месте, и нам не хватит места для кода, который должен формировать на вывод все символы фразы **Malbolge source**. Остается второй вариант.

Далее, нам нужен код, который будет формировать вывод. Для вывода символа предназначена инструкция **<**, которая читает значение из регистра **A**. Значит, до вызова этой инструкции мы должны записать в регистр **A** нужное нам значение. В спецификации указаны 2 инструкции, с помощью которых можно это сделать: __\*__ и **p**. Первая производит циклический сдвиг значения, лежащего по адресу **D** и сохраняет это значение в **A**, вторая вычисляет значение операци **Crazy** между значением по адресу **D** и значением в регистре **A** и перезаписывает последнее результатом. Выходит, наш исходный код будет выглядеть следующим образом:
```
...i[{набор из инструкций}o...o{набор из инструкций}oo]...[{набор из *, p}<...<{набор из *, p}<v]
```
где **o** - nop-инструкция, не производящая никаких полезных действий, **v** - инструкция окончания выполнения кода.

